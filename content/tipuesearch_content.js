var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 協同產品設計實習 - Collaborative Product Design Practice \n 學員作業網站： \xa0https://mdecd2025.github.io/hw-Manto8/ \n 學員作業倉儲： https://github.com/mdecd2025/hw-Manto8/settings/pages \n 組別作業倉儲： https://github.com/mdecd2025/2a-ag5 \n \n 課程代號: cd2025 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n', 'tags': '', 'url': 'About.html'}, {'title': 'List', 'text': '', 'tags': '', 'url': 'List.html'}, {'title': 'Week', 'text': '', 'tags': '', 'url': 'Week.html'}, {'title': 'w1', 'text': '心得：上個禮拜班上多了幾位重補修的學長姊，所以老師從基本的建立個人網站及倉儲開始教起。 \n', 'tags': '', 'url': 'w1.html'}, {'title': 'w3', 'text': '列出各班未納入分組名單的名單 \n 2a未加入團隊學員 \n 列出2a還未納入的學員名單 \n', 'tags': '', 'url': 'w3.html'}, {'title': 'w4', 'text': 'putty的使用方法、fossil的操作方式 \n', 'tags': '', 'url': 'w4.html'}, {'title': 'w5', 'text': '問題：請用繁體中文詳細說明資料 \n \n 什麼是 Webots？ \n Webots 是一款專業的開源移動機器人仿真軟件，由 Cyberbotics 公司開發。它提供了一個快速原型設計環境，讓使用者可以在虛擬的 3D 空間中創建具有物理特性的機器人及其環境。Webots 最初由瑞士洛桑聯邦理工學院（EPFL）開發，後於 2018 年 12 月起以 Apache 2.0 許可證開源，廣泛應用於教育、研究和工業領域。它的核心基於開源物理引擎 ODE（Open Dynamics Engine）和 OpenGL 技術，支持 Windows、Linux 和 macOS 操作系統，並兼容多種編程語言，包括 C、C++、Python、Java 和 MATLAB。 \n 簡單來說，Webots 是一個強大的工具，用於模擬機器人的行為、測試控制算法，並在虛擬環境中驗證設計，而無需直接使用實體機器人。 \n \n 我可以用 Webots 做什麼？ \n Webots 的功能非常豐富，以下是一些主要用途： \n \n 機器人設計與建模 ：\n \n 使用內建的 3D 編輯器創建機器人模型，或導入外部 CAD 文件（如 Blender 或 URDF 格式）。 \n 設定機器人的物理屬性，例如質量、摩擦力、關節等。 \n \n \n 仿真與測試 ：\n \n 模擬機器人在不同環境中的行為，如輪式機器人、腿式機器人或飛行機器人。 \n 測試各種傳感器（如距離傳感器、攝影機、陀螺儀）和執行器（如馬達、驅動輪）的運作。 \n \n \n 控制算法開發 ：\n \n 編寫控制器程式，讓機器人執行特定任務，例如避障、巡線或協作。 \n 支持多種編程語言，適合不同技術背景的使用者。 \n \n \n 教育與研究 ：\n \n 用於機器人學課程，教授運動學、動力學和人工智能等概念。 \n 研究多智能體系統（如群體智慧）或自適應行為（如神經網絡、遺傳算法）。 \n \n \n 真實機器人接口 ：\n \n 將模擬結果轉移到真實機器人（如 e-puck、Nao、DARwIn-OP），實現虛實結合。 \n \n \n 比賽與原型開發 ：\n \n 參與機器人競賽（如 Robotstadium）或快速開發機器人原型，應用於汽車、航空航天或消費品行業。 \n \n \n \n 總之，Webots 適合用來模擬、驗證和優化機器人系統，無論是單一機器人還是多機器人協作場景。 \n 使用 Webots 需要知道什麼？ \n 要有效使用 Webots，您需要掌握以下知識和技能： \n \n 基本電腦操作 ：\n \n 熟悉 Windows、Linux 或 macOS 操作系統的基本使用。 \n 確保您的電腦符合最低硬體要求：雙核 CPU（建議四核）、2GB RAM（建議更多）、支援 OpenGL 3.3 的顯卡（推薦 NVIDIA 或 AMD）。 \n \n \n 編程基礎 ：\n \n 熟悉至少一種 Webots 支持的語言：C、C++、Python、Java 或 MATLAB。 \n 理解基本的程式設計概念，如變數、迴圈、條件語句等。 \n \n \n 機器人學概念 ：\n \n 了解機器人的基本組成，例如傳感器、執行器和控制器。 \n 對物理模擬（如質量、摩擦力、碰撞檢測）有初步認識。 \n \n \n Webots 介面與功能 ：\n \n 學習 Webots 的圖形介面，包括場景樹（Scene Tree）、3D 視圖和文字編輯器。 \n 熟悉如何創建「世界」（World）、添加物件和機器人，以及編寫控制器。 \n \n \n 官方資源 ：\n \n 閱讀 Webots 的《用戶指南》（User Guide）和《參考手冊》（Reference Manual），這兩個文件提供了詳細的操作說明和 API 介紹。 \n 使用內建的教學範例（Tutorials）逐步學習。 \n \n \n \n 初學者可以從簡單的任務開始，例如讓一個輪式機器人移動，然後逐步進階到更複雜的應用。 \n 如何獲得 Webots 的用戶支持？ \n Webots 提供了多種用戶支持管道： \n \n 官方文件 ：\n \n 《用戶指南》和《參考手冊》可在 Webots 官網（ https://cyberbotics.com）或軟件內獲取，提供全面的操作和  API 說明。 \n \n \n 社區支持 ：\n \n GitHub 討論區 ：Webots 的開源代碼托管於 GitHub（ https://github.com/cyberbotics/webots），您可以在「Discussions」區域提問或搜索解答。 \n 論壇與社群 ：加入 Webots 的 Discord 伺服器或相關機器人學社群，與其他使用者交流。 \n \n \n 技術支持 ：\n \n 如果您是付費用戶（Webots 有商業版本），可以通過 Cyberbotics 的官方郵箱（ support@cyberbotics.com ）獲得專業支持。 \n 開源版本主要依賴社區自助，但問題通常也能在 GitHub 上得到回應。 \n \n \n 教學資源 ：\n \n Webots 內建「導覽之旅」（Guided Tour），展示範例世界和功能。 \n B 站或 YouTube 上有許多中文和英文教學影片，例如「Webots 超詳細入門教程」。 \n \n \n \n 建議先查閱官方文件和範例，若無法解決問題，再向社區或官方求助。 \n Webots 仿真中的「世界」（World）是什麼？ \n 在 Webots 中，「世界」（World）是指機器人及其環境的 3D 虛擬描述。它是一個完整的仿真場景，包含以下元素： \n \n 物件描述 ：每個物件的位置、方向、幾何形狀、外觀（如顏色、紋理）和物理屬性（如質量、摩擦係數）。 \n 層次結構 ：世界以樹狀結構組織（基於 VRML97 格式），物件可包含子物件，例如一個機器人可能包含輪子、傳感器和關節。 \n 文件格式 ：世界儲存在  .wbt  文件中，通常位於 Webots 項目的  worlds  子目錄。 \n \n 世界文件不包含機器人的控制器程式，只指定每個機器人使用的控制器名稱。它定義了仿真的環境和初始條件，例如地面、地形、光線和障礙物。 \n Webots 中的「控制器」（Controller）是什麼？ \n 「控制器」（Controller）是控制 Webots 中機器人行為的程式。它負責： \n \n 讀取傳感器數據 ：如距離傳感器或攝影機的輸入。 \n 執行邏輯運算 ：根據數據計算機器人的動作。 \n 發送指令 ：控制執行器，例如讓馬達轉動或輪子移動。 \n \n 特性 ： \n \n 編程語言 ：可用 C、C++、Java、Python 或 MATLAB 編寫。 \n 獨立進程 ：每個控制器作為 Webots 的子進程運行，不與主程式共享記憶體，可在不同 CPU 核心上執行。 \n 儲存位置 ：控制器源文件和編譯後的文件位於項目的  controllers  子目錄。 \n \n 例如，一個簡單的控制器可能讓機器人檢測障礙物並轉向避開。同一控制器程式可被多個機器人共用，但每個機器人會啟動獨立的進程。 \n Webots 中的「監督控制器」（Supervisor Controller）是什麼？ \n 「監督控制器」（Supervisor Controller）是一種特殊類型的控制器，具有更高的權限，用於管理和控制整個仿真環境。它的特點包括： \n \n 特權操作 ：普通控制器只能控制機器人本身，而監督控制器可以執行以下操作：\n \n 移動機器人到指定位置。 \n 更改仿真環境（如添加或移除物件）。 \n 控制仿真流程（如暫停、重啟或錄製影片）。 \n \n \n 啟用方式 ：在場景樹中，將機器人的  supervisor  欄位設為  TRUE ，該機器人即可使用監督控制器。 \n 編程語言 ：與普通控制器相同，支持 C、C++、Python 等。 \n \n 應用場景 ： \n \n 在多機器人仿真中，監督控制器可用來協調各機器人的行為。 \n 用於測試或調試，例如隨機放置障礙物或記錄機器人軌跡。 \n \n 例如，一個監督控制器可能監控所有機器人的位置，並在某個機器人偏離路徑時將其重置。 \n', 'tags': '', 'url': 'w5.html'}, {'title': 'w6', 'text': '要啟動webots在可攜裡面輸入 webotsw 就可以開啟軟體，前提是要檔案內要 Webots_2025a_web.7z 才可以開啟，並放在data頁面，如果是舊版可攜套件 也可在.bat啟動編碼中自行設定加入 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n REM  for   Webots \n set   PYTHON_PATH = % Disk % :\\Python313 \n \xa0\xa0 \xa0 \n REM  for   webots \n set \xa0  path_webots = % Disk % :\\Webots_2025a\\msys64\\mingw64\\ bin ; % Disk % :\\Webots_2025a\\msys64\\usr\\ bin \n \xa0\xa0 \xa0 \n path = % Disk % :; % path_python % ; % path_git % ; % path_copsim % ; % path_msys2 % ; % path_miketex % ; % path_flutter % ; % path_node % ; % path_tcc % ; % path_postgresql % ; % path_range % ; % path_lua % ; % path_core % ; % path_putty % ; % path_vscode % ; % RUST_PATH % ; % path_erlang % ; % path_nodejs % ; % path_haskell % ; % path_scite % ; % path_xsltproc % ; % path_gnuplot % ; % path_openssl % ; % path_poppler % ; % path_webots % ; % path_blender % ; % path % ; \n \n \n \n \n \n \n \n 在開啟webots時系統會有跳出警告防火牆，其中一定要選擇允許，否則防火牆會擋 \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w8', 'text': '複習webots \xa0 SolidReference \xa0節點的用法說明，用在 Joint 節點的 endPoint 欄位中，用來指向一個現有的 Solid 或靜態環境\xa0<static environment>。通過這種方式，可以閉合機械迴圈。 \n 當指向一個 Solid 時，唯一的限制是 Solid 和 Joint 必須是某個共同上層 Solid 的下層。 \n 意思即是指 SolidReference 是一個引用類型，允許在 Joint 節點的 endPoint 欄位中指定某個目標。 \n', 'tags': '', 'url': 'w8.html'}, {'title': 'w10', 'text': '已知Webots2025a有bug，無法使用 Transform 節點和閃退的問題，因此可以下載 Webots2023b 版本。 \n 若想要擁有2025a的版本和2023b的版本可以在編輯器內將2025a的文字更改為2023b，並另存新檔即可。 \n', 'tags': '', 'url': 'w10.html'}, {'title': 'w11', 'text': 'webots小組協同模擬及 fourbar_box複習 \n', 'tags': '', 'url': 'w11.html'}, {'title': 'w12', 'text': '本週開始需依照team上，在規定時間完成對應的HW、Exam等網頁內容，並在規定時間內完成表單填寫。 \n', 'tags': '', 'url': 'w12.html'}, {'title': 'w16', 'text': '檔案： /downloads/HW1-w16.zip \n \n 心得：使用HW1做變換將紅色改為20公分、藍色改為80公分、綠色改為45公分，利用solvespace觀察改變後的角度變化，並將Webots原有的角度數值做更改，最後再將馬達的程式輸入並存檔，四連桿即可作動。', 'tags': '', 'url': 'w16.html'}, {'title': 'task', 'text': '', 'tags': '', 'url': 'task.html'}, {'title': 'task2', 'text': 'ssh \n 1.利用puttygen.exe建立金鑰，複製ssh-ra到Github，之後到按Load存入Y槽 \n \n \n', 'tags': '', 'url': 'task2.html'}, {'title': 'task3', 'text': '檔案： /downloads/solvespace.7z \n 四連桿1-3 \n \n 四連桿4 \n \n 四連桿5-7 \n \n 四連桿組合 \n \n', 'tags': '', 'url': 'task3.html'}, {'title': 'Homework', 'text': '作業 (30%) \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n part1: \n 請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n Blender4.2.7z \n part2: \n 請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景. \n base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec. \n part3: \n 模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停. \n 參考資料: \n cd2025_hw1_demo.7z \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景. \n 參考資料: \n fourbar_slvs.7z \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 ( 參考影片 )後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統. \n 參考資料: \n 參考資料: \n fourbar_ball_throwing_linkage.slvs \n sixbar_ball_throwing_linkage.slvs \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': 'HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 吳柏諺-41223117 \n 檔案： 41223117-downloads/HW1.7z \n \n \n \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': 'HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 吳柏諺-41223117 \n 檔案： /downloads/41223117_HW2.7z \n \n \n \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': 'HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 吳柏諺-41223117 \n 檔案： /downloads/basketball_game.zip \n \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Midterm', 'text': '本課程所繳交的期中成績為學員自評之學習期望成績. \n 期中考週的自評期望成績繳交流程: \n \n 整理先前所完成的各週的進度、作業網頁內容以及心得 \n 拍攝期中自評影片, 上傳至 Youtube 後, 以" 國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號 "為影片標題後嵌入本頁面中 \n 回填期中自評表單 \n 上傳學員期中成績 \n \n 各週進度: \n 各週網頁內容: \n 期中心得: \n 期中自評影片: \n \n \n', 'tags': '', 'url': 'Midterm.html'}, {'title': 'Exam', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam2 (10%): 利用 CAD 零組件建立模擬場景\xa0 \n 各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n 各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站. \n 協同分組方式: \n \n 分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁. \n \n', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 -吳柏諺-41223117 \n 檔案： 41223117-downloads/EX1.zip \n \n 註解：先利用solvespace畫圖知道各個節點的角度，之後用作業一進行修改並加入 transform即可完成。 \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': 'Exam2 (10%): 利用 CAD 零組件建立模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 吳柏諺-41223117 \n 檔案： /downloads/41223117_Exam2.7z \n \n 註解：Exam2為HW2的延伸，其中最大的差別就在於 連桿短桿需用自己的學號設計 ，了解如何將結點和角度進行修改就會非常簡單。 \n', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3 (20%): Webots 機電模擬場景的協同設計 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 吳柏諺-41223117 \n 檔案： /downloads/41223117-Exam3.zip \n 伺服端： \n \n 七段顯示器： \n \n 控制平台車： \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Final', 'text': '期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%) \n 題目:  Webots 動態投籃模擬系統的協同設計 \n 說明:  \n 籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上. \n 操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止. \n 請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中. \n 影片標題:  國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題 \n 投球數量限制: \n \n from controller import Supervisor, Keyboard\nimport time\nimport random\nimport numpy as np\nimport re\n \n# ----------------- 參數區 -----------------\nHOOP_CENTER = [0.622, -0.103, 0.742838]\nBALL_DEF_PATTERN = re.compile(r"Sphere_\\d+")\nsupervisor = Supervisor()\ntimestep = int(supervisor.getBasicTimeStep())\nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n \nsphere_radius = 0.1\nTRAJECTORY_POINT_RADIUS = 0.03\nTRAJECTORY_POINT_STEP = 0.12\nTRAJECTORY_MAX_POINTS = 5\n \nwaiting_ball_def = None\nwaiting_ball_info = None\nlast_key_time = 0\ndebounce_time = 0.5\ndefault_feed_pos = (-0.35, 0.0, 0.9)\nPRINT_INTERVAL = 0.2\n \ncurrent_tracked_def = None\nlast_print_time = time.time()\n \ntrajectory_points = []\n \n# 新增球數上限與計數\nmax_balls = 8\nballs_created = 0\n \ndef axis_angle_to_rotation_matrix(axis, angle):\n    x, y, z = axis\n    c = np.cos(angle)\n    s = np.sin(angle)\n    C = 1 - c\n    return np.array([\n        [x*x*C + c,   x*y*C - z*s, x*z*C + y*s],\n        [y*x*C + z*s, y*y*C + c,   y*z*C - x*s],\n        [z*x*C - y*s, z*y*C + x*s, z*z*C + c]\n    ])\n \ndef generate_valid_def_name(base_name="Sphere"):\n    timestamp = int(supervisor.getTime() * 1000)\n    return f"{base_name}_{timestamp}_{random.randint(0, 10000)}"\n \ndef generate_random_color():\n    return random.random(), random.random(), random.random()\n \ndef youbot_local_to_world(local_pos):\n    youbot_node = supervisor.getFromDef(\'youbot\')\n    if youbot_node is None:\n        raise RuntimeError("找不到 DEF 為 youbot 的 Robot 物件")\n    youbot_translation = np.array(youbot_node.getField(\'translation\').getSFVec3f())\n    youbot_rotation = youbot_node.getField(\'rotation\').getSFRotation()\n    youbot_axis = youbot_rotation[:3]\n    youbot_angle = youbot_rotation[3]\n    youbot_rot_mat = axis_angle_to_rotation_matrix(youbot_axis, youbot_angle)\n    rotated = youbot_rot_mat @ np.array(local_pos)\n    world_pos = youbot_translation + rotated\n    return tuple(world_pos)\n \ndef create_static_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n \ndef create_dynamic_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n      physics Physics {{\n        mass 0.01\n        density -1\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n \ndef create_trajectory_point(pos):\n    def_name = generate_valid_def_name("TrajectoryPt")\n    sphere_string = f"""\n    DEF {def_name} Transform {{\n      translation {pos[0]} {pos[1]} {pos[2]}\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {TRAJECTORY_POINT_RADIUS}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor 1 0.7 0\n              transparency 0.3\n            }}\n          }}\n        }}\n      ]\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n    return def_name\n \ndef delete_trajectory_points():\n    global trajectory_points\n    for _, def_name in trajectory_points:\n        node = supervisor.getFromDef(def_name)\n        if node:\n            node.remove()\n    trajectory_points.clear()\n \ndef create_static_sphere(supervisor, x, y, z):\n    global waiting_ball_def, waiting_ball_info\n    def_name = generate_valid_def_name()\n    waiting_ball_def = def_name\n    r, g, b = generate_random_color()\n    world_pos = youbot_local_to_world((x, y, z))\n    waiting_ball_info = (world_pos, r, g, b)\n    create_static_ball(def_name, world_pos, r, g, b)\n \ndef activate_dynamic_ball():\n    global waiting_ball_def, waiting_ball_info\n    if waiting_ball_def is None or waiting_ball_info is None:\n        return\n    ball_node = supervisor.getFromDef(waiting_ball_def)\n    if ball_node is not None:\n        ball_node.remove()\n        supervisor.step(int(supervisor.getBasicTimeStep()))\n    world_pos, r, g, b = waiting_ball_info\n    create_dynamic_ball(waiting_ball_def, world_pos, r, g, b)\n    waiting_ball_def = None\n    waiting_ball_info = None\n \ndef is_ball_landed(pos, threshold_z=0.13):\n    return pos[2] < threshold_z\n \nprint("按 F 產生一顆靜止球，按 M 讓球變 dynamic 可擊出（最多只有5個軌跡點跟著球跑，球落地後軌跡自動消失）")\n \nwhile supervisor.step(timestep) != -1:\n    key = keyboard.getKey()\n    current_time = time.time()\n \n    if key == ord(\'F\') and (current_time - last_key_time >= debounce_time):\n        if balls_created >= max_balls:\n            print("遊戲結束，已生成10顆球，不可再產生新球。")\n        elif waiting_ball_def is None:\n            create_static_sphere(supervisor, *default_feed_pos)\n            current_tracked_def = waiting_ball_def\n            delete_trajectory_points()\n            balls_created += 1\n        else:\n            print("還有一顆球等待擊出，請先擊出再產生新球。")\n        last_key_time = current_time\n \n    if key == ord(\'M\') and (current_time - last_key_time >= debounce_time):\n        activate_dynamic_ball()\n        last_key_time = current_time\n \n    if current_tracked_def is not None:\n        ball_node = supervisor.getFromDef(current_tracked_def)\n        if ball_node is not None:\n            pos = ball_node.getPosition()\n            if current_time - last_print_time >= PRINT_INTERVAL:\n                #print(f"球 {current_tracked_def} 絕對座標: [{pos[0]:.4f}, {pos[1]:.4f}, {pos[2]:.4f}]")\n                last_print_time = current_time\n            if (not trajectory_points) or np.linalg.norm(np.array(pos) - np.array(trajectory_points[-1][0])) > TRAJECTORY_POINT_STEP:\n                def_name = create_trajectory_point(pos)\n                trajectory_points.append((pos, def_name))\n                if len(trajectory_points) > TRAJECTORY_MAX_POINTS:\n                    _, old_def = trajectory_points.pop(0)\n                    node = supervisor.getFromDef(old_def)\n                    if node:\n                        node.remove()\n            if is_ball_landed(pos):\n                delete_trajectory_points()\n        else:\n            delete_trajectory_points()\n            current_tracked_def = None \n 投球機構自動賦歸: \n \n from controller import Robot, Keyboard\nimport time  # 為了賦歸計時\n \n# === 常數定義 ===\nTIME_STEP = 32\nMAX_VELOCITY = 10.0\nANGLE_STEP = 40 * 3.14159 / 180  # 40 度轉為弧度\nPOSITION_M = ANGLE_STEP          # 升起位置 (+40°)\nPOSITION_K = 0.0                 # 回復位置 (0°)\n \n# === 初始化 Webots 裝置 ===\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\n \nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n \n# === 嘗試取得馬達與感測器 ===\ntry:\n    motor = robot.getDevice(\'motor1\')\n    sensor = robot.getDevice(\'motor1_sensor\')\n    sensor.enable(timestep)\n    mechanism_enabled = True\nexcept Exception:\n    mechanism_enabled = False\n \n# === 嘗試取得輪子裝置 ===\ntry:\n    wheels = [robot.getDevice(f"wheel{i+1}") for i in range(4)]\n    for wheel in wheels:\n        wheel.setPosition(float(\'inf\'))  # 啟用速度模式\n        wheel.setVelocity(0)             # 初始速度為 0\n    platform_enabled = True\nexcept Exception:\n    platform_enabled = False\n \n# === 初始提示 ===\nprint("使用方向鍵控制平台移動：↑ 前進，↓ 後退，← 左轉，→ 右轉")\nprint("按 M 可升起機構，將於 1 秒後自動回復")\nprint("按 Q 離開程式")\n \n# === 馬達控制狀態 ===\nkey_pressed = {\'m\': False}\nmechanism_raised = False       # 是否目前為升起狀態\nraise_start_time = None        # 升起開始時間（記錄用）\n \n# === 主控制迴圈 ===\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()\n    current_time = time.time()\n \n    # === 四輪平台移動控制 ===\n    if platform_enabled:\n        if key == Keyboard.UP:\n            for wheel in wheels:\n                wheel.setVelocity(MAX_VELOCITY)\n        elif key == Keyboard.DOWN:\n            for wheel in wheels:\n                wheel.setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.LEFT:\n            wheels[0].setVelocity(MAX_VELOCITY)\n            wheels[1].setVelocity(-MAX_VELOCITY)\n            wheels[2].setVelocity(MAX_VELOCITY)\n            wheels[3].setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.RIGHT:\n            wheels[0].setVelocity(-MAX_VELOCITY)\n            wheels[1].setVelocity(MAX_VELOCITY)\n            wheels[2].setVelocity(-MAX_VELOCITY)\n            wheels[3].setVelocity(MAX_VELOCITY)\n        elif key == ord(\'Q\') or key == ord(\'q\'):\n            print("離開程式...")\n            break\n        else:\n            for wheel in wheels:\n                wheel.setVelocity(0)\n \n    # === 機構升起＋自動賦歸控制 ===\n    if mechanism_enabled:\n        motor_position = sensor.getValue()\n \n        # 按下 M 鍵時觸發升起（且尚未升起）\n        if key == ord(\'M\') or key == ord(\'m\'):\n            if not key_pressed[\'m\'] and not mechanism_raised:\n                motor.setPosition(POSITION_M)\n                print("投球")\n                mechanism_raised = True\n                raise_start_time = current_time\n            key_pressed[\'m\'] = True\n        else:\n            key_pressed[\'m\'] = False\n \n        # 已升起 → 檢查是否超過1秒 → 回復\n        if mechanism_raised and raise_start_time is not None:\n            if current_time - raise_start_time >= 1.0:\n                motor.setPosition(POSITION_K)\n                print("自動回復")\n                mechanism_raised = False\n                raise_start_time = None \n 籃框隨機移動和感測器角度調整: \n \n from controller import Robot\nimport random\n \n# === 常數 ===\nMAX_VELOCITY = 10.0\nMOVE_DURATION = 1.5\nDISTANCE_THRESHOLD = 0.17\nSCORE_INTERVAL = 1.0  # 避免連續得分\n \n# === 初始化 ===\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\nemitter = robot.getDevice("score_emitter")\nscore_to_send = 2\nsensor = robot.getDevice(\'sensor\')\nsensor.enable(timestep)\n \n# === 馬達 ===\nwheels = [robot.getDevice(f"wheel{i}") for i in range(5, 9)]\nfor w in wheels:\n    w.setPosition(float(\'inf\'))\n    w.setVelocity(0)\n \ndef set_wheel_velocity(v1, v2, v3, v4):\n    wheels[0].setVelocity(v1)\n    wheels[1].setVelocity(v2)\n    wheels[2].setVelocity(v3)\n    wheels[3].setVelocity(v4)\n \n# === AD轉距離對照表 ===\nlookup_table = [\n    (1000, 0.00), (620, 0.12), (372, 0.13),\n    (248, 0.14), (186, 0.15), (0, 0.18)\n]\n \ndef ad_to_distance(ad_value):\n    for i in range(len(lookup_table) - 1):\n        a0, d0 = lookup_table[i]\n        a1, d1 = lookup_table[i + 1]\n        if a1 <= ad_value <= a0:\n            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)\n    return lookup_table[0][1] if ad_value > lookup_table[0][0] else lookup_table[-1][1]\n \n# === 狀態 ===\nscore = 0\nlast_score_time = 0\nis_moving = False\nmove_timer = 0\ncurrent_velocity = (0, 0, 0, 0)\nlast_time = robot.getTime()\n \nprint("⚙️ 初始靜止：當感測器感應到球時得分，然後才啟動隨機移動")\n \n# === 主迴圈 ===\nwhile robot.step(timestep) != -1:\n    now = robot.getTime()\n    dt = now - last_time\n    last_time = now\n \n    sensor_value = sensor.getValue()\n    distance = ad_to_distance(sensor_value)\n \n    if is_moving:\n        set_wheel_velocity(*current_velocity)\n        move_timer -= dt\n        if move_timer <= 0:\n            # 移動時間結束，停止\n            is_moving = False\n            set_wheel_velocity(0, 0, 0, 0)\n    else:\n        set_wheel_velocity(0, 0, 0, 0)\n        if distance < DISTANCE_THRESHOLD and (now - last_score_time) > SCORE_INTERVAL:\n            # 得分並開始移動\n            score += score_to_send\n            print(f"🎯 得分！距離 {distance:.3f} m，總分：{score}")\n            emitter.send(str(score_to_send).encode(\'utf-8\'))\n            last_score_time = now\n \n            # 啟動隨機移動\n            def rv(): return random.uniform(-MAX_VELOCITY, MAX_VELOCITY)\n            current_velocity = (rv(), rv(), rv(), rv())\n            move_timer = MOVE_DURATION\n            is_moving = True \n 最終成品展示: \n \n 使用的程式分別是: \n 投籃機 fourbar_test \n 生成球 ball_test \n 籃框 move_test \n 直接創一新的程式控制器，保留原始的程式碼，在出錯的時候還能切回原始代碼，進行不同面向的修改。 \n 檔案下載: \n cd2025_final_41223126.7z \n 報告: \n cd2025-ag-5-期末報告.pdf \n 心得: \n 一開始我先做球數定量限制的部分，我用原本的生成球程式來進行修改，保留原本透過按鍵來生成球的部分，另外再讓 ChatGPT 幫我加入，生成球數的限制，當總生成球數等於8球時，送出訊息 [ 遊戲結束，已投出8球 ] ，並停止按鍵生成球的功能，來達到意義上的定量限制，當然也能更改成更多或更少球數。投籃機的本體部分，我將原先的投籃機制做了改變，原本是按下 M 驅動擺臂投出球，按下 K 讓擺臂回到 0 度，也就是初始的位置，我將以上兩個按鍵的功能進行整合，變成按下 M 投出後等待 1 秒後回歸到原點，這樣可以避免還沒將擺臂正，就將球生成導致兩者相互碰撞，偏移原本的準心和浪費一次投球的機會。籃框隨機移動的部分，我使用原本的程式將裡面的控制部分移除，讓 ChatGPT 幫我寫一個當得分偵測器，偵測到進球得分後，雖機的進行小幅度移動，來改變籃框的位置，所以每進一球，籃框就會透過移動或旋轉來改變位置，直到遊戲結束', 'tags': '', 'url': 'Final.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}]};